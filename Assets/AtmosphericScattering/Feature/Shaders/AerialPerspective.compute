#pragma enable_d3d11_debug_symbols

#pragma target 5.0

#pragma kernel AerialPerspective

#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl"
#include "Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl"
#include "Packages/com.unity.render-pipelines.universal/ShaderLibrary/Lighting.hlsl"
#include "./AtmosphericScatteringData.hlsl"

RWTexture2DArray<half4> _PrecomputedAerialPerspective;
float4 _AerialPerspectiveParams; // size.xy, n_slice

TEXTURE2D(_PrecomputedTransmittance);
SAMPLER(transmittance_sampler_linear_clamp);
TEXTURE2D(_PrecomputedMultiScattering);
SAMPLER(multiScattering_sampler_linear_clamp);

[numthreads(8,8,1)]
void AerialPerspective (uint3 id : SV_DispatchThreadID)
{
    ScatteringParameters params = CollectParams();
    // GroupMemoryBarrierWithGroupSync();
    float n_slice = _AerialPerspectiveParams.z;
    float inv_n_slice = rcp(n_slice);
    float step_per_slice = 4.0;
    float inv_step_per_slice = rcp(step_per_slice);
    float2 uv = ((float2)id.xy + 0.5) / _AerialPerspectiveParams.xy;
    uv = uv * 2.0 - 1.0;
#if UNITY_UV_STARTS_AT_TOP
    uv.y = -uv.y;
#endif
    
    float4 ndc_start_pos = float4(uv, UNITY_NEAR_CLIP_VALUE, 1.0);
    float4 ndc_end_pos = float4(uv, UNITY_RAW_FAR_CLIP_VALUE, 1.0);
    float4 view_start_pos = mul(UNITY_MATRIX_I_P, ndc_start_pos);
    float4 view_end_pos = mul(UNITY_MATRIX_I_P, ndc_end_pos);
    view_start_pos /= view_start_pos.w;
    view_end_pos /= view_end_pos.w;
    float3 world_start_pos = TransformViewToWorld(view_start_pos);
    float3 world_end_pos = TransformViewToWorld(view_end_pos);
    world_start_pos = GetScaledWorldPosition(world_start_pos);
    world_end_pos = GetScaledWorldPosition(world_end_pos);

    float3 slice_start = GetScaledWorldPosition(_WorldSpaceCameraPos);
    
    Light light = GetMainLight();
    float3 lightCol = light.color;
    float3 lightDir = light.direction;
    float scatteringAngle = dot(lightDir, normalize(world_end_pos - world_start_pos));

    float3 atmo = 0.0f;
    float3 depth = 0.0f;
    bool hit = false;
    float i;
    
    for (i = 0.0; i < n_slice && !hit; i += 1.0)
    {
        float3 slice_end = lerp(world_start_pos, world_end_pos, (i + 0.5) * inv_n_slice);
        float ds = length(slice_end - slice_start) * inv_step_per_slice;
        for (float j = 0.0; j < step_per_slice; j += 1.0)
        {
            float3 p = lerp(slice_start, slice_end, (j + 0.5) * inv_step_per_slice);
            float h = GetHeight(params, p);
            if (h < 0)
            {
                hit = true;
                break;
            }
            float cosTheta = dot(normalize(p - params.earthCenter), lightDir);
            float3 scattering = RayleighScattering(params, h) + MieScattering(params, h);
            float3 absorption = MieAbsorption(params, h) + OzoneAbsorption(params, h);
            depth += (scattering + absorption) * ds;
            float hitEarth = HitEarth(params, p, lightDir) ? 0.0 : 1.0;
            float2 transUV = GetTransmittanceLutUV(params, h, cosTheta);
            float3 trans2 = SAMPLE_TEXTURE2D_LOD(_PrecomputedTransmittance, transmittance_sampler_linear_clamp, transUV, 0).rgb;
            float3 trans1 = exp(-depth);
            atmo += trans1 * Scattering(params, h, scatteringAngle) * trans2 * hitEarth * ds;
            transUV.x = 0.5 + 0.5 * cosTheta;
            transUV.y = h / params.topHeight;
            float3 multiScattering = SAMPLE_TEXTURE2D_LOD(_PrecomputedMultiScattering, multiScattering_sampler_linear_clamp, transUV, 0).rgb;
            atmo += trans1 * scattering * multiScattering * ds * params.atmosphereMultiScatteringIntensity;
        }
        float3 trans = exp(-depth);
        float mean_trans = dot(trans, rcp(float3(3.0, 3.0, 3.0)));
        _PrecomputedAerialPerspective[uint3(id.xy, i)] = half4(atmo * lightCol * params.atmosphereIntensity, mean_trans);
        slice_start = slice_end;
    }
    while (i < n_slice)
    {
        float3 trans = exp(-depth);
        float mean_trans = dot(trans, rcp(float3(3.0, 3.0, 3.0)));
        _PrecomputedAerialPerspective[uint3(id.xy, i)] = half4(atmo * lightCol * params.atmosphereIntensity, mean_trans);
        i += 1.0;
    }
}
